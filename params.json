{
  "name": "stm-sdk-android",
  "tagline": "An Android SDK that can be used to consume the Shout to Me cloud services",
  "body": "# Shout to Me Android SDK\r\n*Version 1.0.6*\r\n## Quickstart Guide\r\nThis guide will show you how to get up and running with the Shout to Me Android SDK in minutes.\r\n### Prerequisites\r\n- A Shout to Me client access token\r\n- [Android Studio](http://developer.android.com/tools/studio/index.html) and all its dependencies. This quickstart guide was developed using Android Studio version 2.1.2\r\n\r\n### Create an Android application\r\nRun through the Android Studio’s Create New Project wizard.  The minimum Android SDK required is **API 15: Android 4.0.3 (IceCreamSandwich)**.  Choose \"Empty Activity\" on the \"Add an Activity to Mobile\" screen.  For the rest of the options, you can leave them set to their defaults.\r\n\r\n![Create new project step 1](https://s3-us-west-2.amazonaws.com/sdk-public-images/as-new-project-1.png)\r\n\r\n![Create new project step 2](https://s3-us-west-2.amazonaws.com/sdk-public-images/as-new-project-2.png)\r\n\r\n![Create new project step 3](https://s3-us-west-2.amazonaws.com/sdk-public-images/as-new-project-3.png)\r\n\r\n![Create new project step 4](https://s3-us-west-2.amazonaws.com/sdk-public-images/as-new-project-4.png)\r\n### Add the Shout to Me Android SDK\r\n\r\n1. In Android Studio, navigate to **File > New > New Module**\r\n2. Select **Import .JAR/.AAR Package** then click **Next**\r\n3. Enter the location of the **shout-to-me-sdk-release.aar** file and then click **Finish**\r\n\r\nAdd the following to your app/build.gradle file dependencies section:\r\n\r\n```gradle\r\ndependencies {\r\n    ...\r\n    \r\n    compile project(\":shout-to-me-sdk-release\")\r\n    compile 'com.google.android.gms:play-services:9.6.0'\r\n    compile 'com.android.volley:volley:1.0.0'\r\n    compile 'com.amazonaws:aws-android-sdk-core:2.2.+'\r\n    compile 'com.amazonaws:aws-android-sdk-sns:2.2.+'\r\n}\r\n```\r\n\r\n(Note the additional dependency on Google Play Services, Volley, and AWS)\r\n\r\nThen click:  **Tools > Android > Sync Project with Gradle Files**\r\n\r\n### Add your Shout to Me client token to AndroidManifest.xml\r\n\r\nAdd the following section into the &lt;application&gt; node of your AndroidManifest.xml.\r\n\r\n```xml\r\n<service\r\n    android:name=\"me.shoutto.sdk.StmService\"\r\n    android:exported=\"false\">\r\n    \r\n    <meta-data\r\n        android:name=\"me.shoutto.sdk.CLIENT_TOKEN\"\r\n        android:value=\"@string/client_token\" />\r\n        \r\n    <meta-data\r\n        android:name=\"me.shoutto.sdk.CHANNEL_ID\"\r\n        android:value=\"@string/channel_id\" />\r\n</service>\r\n```\r\n\r\nAnd then add the following to your app/src/main/res/values/strings.xml file:\r\n\r\n```xml\r\n<string name=\"client_token\">[Your client token]</string>\r\n<string name=\"channel_id\">s2m-sandbox</string>\r\n```\r\n\r\n### Use the Shout to Me Android SDK\r\nYou are now able to begin coding with the Shout to Me Android SDK.  Assuming you used the default names when creating the projects, modify the following files so they look like these:\r\n\r\n**MainActivity.java**\r\n\r\n```java\r\npackage com.mycompany.teststmsdk;\r\n\r\nimport android.Manifest;\r\nimport android.app.Dialog;\r\nimport android.content.ComponentName;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.content.ServiceConnection;\r\nimport android.os.IBinder;\r\nimport android.support.v4.app.ActivityCompat;\r\nimport android.support.v7.app.AppCompatActivity;\r\nimport android.os.Bundle;\r\nimport android.util.Log;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\n\r\nimport com.google.android.gms.common.ConnectionResult;\r\nimport com.google.android.gms.common.GoogleApiAvailability;\r\n\r\nimport me.shoutto.sdk.Callback;\r\nimport me.shoutto.sdk.Shout;\r\nimport me.shoutto.sdk.StmError;\r\nimport me.shoutto.sdk.StmRecorderActivity;\r\nimport me.shoutto.sdk.StmResponse;\r\nimport me.shoutto.sdk.StmService;\r\nimport me.shoutto.sdk.User;\r\n\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    private static final String TAG = MainActivity.class.getSimpleName();\r\n    private StmService stmService;\r\n    private Boolean isStmServiceBound = false;\r\n    private Shout newlyCreatedShout;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n\r\n        // Intent to bind to the Shout to Me service\r\n        Intent intent = new Intent(this, StmService.class);\r\n        bindService(intent, stmServiceConnection, Context.BIND_AUTO_CREATE);\r\n\r\n        // Show user a Dialog to update Google Play Services if required version is not installed\r\n        GoogleApiAvailability googleApiAvailability = GoogleApiAvailability.getInstance();\r\n        int val = googleApiAvailability.isGooglePlayServicesAvailable(this);\r\n        if (val != ConnectionResult.SUCCESS) {\r\n            Dialog gpsErrorDialog = googleApiAvailability.getErrorDialog(this, val, 2);\r\n            gpsErrorDialog.show();\r\n        }\r\n\r\n        final EditText editText = (EditText) findViewById(R.id.editTextUserHandle);\r\n        editText.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                editText.setError(null);\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n\r\n        if (isStmServiceBound) {\r\n            unbindService(stmServiceConnection);\r\n        }\r\n    }\r\n\r\n    public void launchRecordingOverlay(View view) {\r\n        if (isStmServiceBound) {\r\n            Log.d(TAG, \"Launching overlay\");\r\n            stmService.setShoutCreationCallback(new Callback<Shout>() {\r\n                @Override\r\n                public void onSuccess(StmResponse<Shout> stmResponse) {\r\n                    Log.d(TAG, \"Shout created successfully. ID = \" + stmResponse.get().getId());\r\n                    newlyCreatedShout = stmResponse.get();\r\n                    showDeleteButton();\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(StmError stmError) {\r\n                    Log.e(TAG, \"An error occurred during shout creation. Message is \" + stmError.getMessage());\r\n                }\r\n            });\r\n\r\n            Intent intent = new Intent(this, StmRecorderActivity.class);\r\n\r\n            // REQUIRED: Set the maximum length of recording time allowed in seconds.\r\n            intent.putExtra(StmRecorderActivity.MAX_RECORDING_TIME_IN_SECONDS, 15);\r\n\r\n            startActivityForResult(intent, 1);\r\n        }\r\n    }\r\n\r\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n\r\n        if (requestCode == 1) {\r\n            if(resultCode == RESULT_OK){\r\n                String result = data.getStringExtra(StmRecorderActivity.ACTIVITY_RESULT);\r\n                Log.d(TAG, \"The recording overlay has closed successfully. Result is: \" + result);\r\n\r\n                if (result.equals(StmService.FAILURE)) {\r\n                    String failureReasonCode = data.getStringExtra(StmRecorderActivity.ACTIVITY_REASON);\r\n                    Log.d(TAG, \"Failure code: \" + failureReasonCode);\r\n                    if (failureReasonCode.equals(StmRecorderActivity.RECORD_AUDIO_PERMISSION_DENIED)) {\r\n\r\n                        // User has not granted access to record audio.  Ask the user for permission now.\r\n                        ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.RECORD_AUDIO }, 0);\r\n                    }\r\n                }\r\n            }\r\n            if (resultCode == RESULT_CANCELED) {\r\n                Log.d(TAG, \"Recording was cancelled\");\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setUserHandle(View view) {\r\n        if (isStmServiceBound) {\r\n            final EditText editText = (EditText)findViewById(R.id.editTextUserHandle);\r\n            String newHandle = editText.getText().toString();\r\n\r\n            // Calling getUser() without a Callback does not guarantee that the object will be\r\n            // instantiated from the server, but is useful for update-only functions.\r\n            User user = stmService.getUser();\r\n            user.setHandle(newHandle);\r\n            user.save(new Callback<User>() {\r\n                @Override\r\n                public void onSuccess(final StmResponse<User> stmResponse) {\r\n                    Log.d(TAG, \"User handle update was successful. Handle is \" + stmResponse.get().getHandle());\r\n                    Log.d(TAG, \"stmReponse.get() && stmService.getUser() point to the same object. \"\r\n                            + (stmResponse.get() == stmService.getUser()));\r\n                    editText.setError(null);\r\n                    editText.setText(stmService.getUser().getHandle());\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(final StmError stmError) {\r\n                    editText.setError(stmError.getMessage());\r\n                    editText.setText(stmService.getUser().getHandle());\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public void deleteShout(View view) {\r\n        if (newlyCreatedShout != null) {\r\n            Log.d(TAG, \"Deleting shout \" + newlyCreatedShout.getId());\r\n            newlyCreatedShout.delete(new Callback<String>() {\r\n                @Override\r\n                public void onSuccess(StmResponse<String> stmResponse) {\r\n                    if (stmResponse.get().equals(StmService.SUCCESS)) {\r\n                        Log.d(TAG, \"Deletion of shout succeeded.\");\r\n                        hideDeleteButton();\r\n                    }\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(StmError stmError) {\r\n                    Log.e(TAG, \"Error occurred deleting shout. Error message: \" + stmError.getMessage());\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private void showDeleteButton() {\r\n        Button deleteButton = (Button) findViewById(R.id.deleteShoutButton);\r\n        deleteButton.setVisibility(View.VISIBLE);\r\n    }\r\n\r\n    private void hideDeleteButton() {\r\n        Button deleteButton = (Button) findViewById(R.id.deleteShoutButton);\r\n        deleteButton.setVisibility(View.INVISIBLE);\r\n    }\r\n\r\n    private ServiceConnection stmServiceConnection = new ServiceConnection() {\r\n\r\n        @Override\r\n        public void onServiceConnected(ComponentName className,\r\n                                       IBinder service) {\r\n            // We've bound to StmService, cast the IBinder and get StmService instance\r\n            Log.d(TAG, \"in onServiceConnected\");\r\n            StmService.StmBinder binder = (StmService.StmBinder) service;\r\n            stmService = binder.getService();\r\n            isStmServiceBound = true;\r\n\r\n            // You can also set the channel programmatically if you have access to more than one channel\r\n            // stmService.setChannelId(\"s2m-sandbox\");\r\n\r\n            // Get a reference to the UI text box\r\n            final EditText handleEditText = (EditText) findViewById(R.id.editTextUserHandle);\r\n\r\n            // Calling getUser() with a Callback will ensure you get an instantiated user object from the server\r\n            stmService.getUser(new Callback<User>() {\r\n                @Override\r\n                public void onSuccess(final StmResponse<User> stmResponse) {\r\n                    Log.d(TAG, \"Shout to Me user has been loaded\");\r\n                    handleEditText.setText(stmResponse.get().getHandle());\r\n                }\r\n\r\n                @Override\r\n                public void onFailure(final StmError stmError) {\r\n                    Log.w(TAG, \"Could not retrieve Shout to Me user.\");\r\n                }\r\n            });\r\n        }\r\n\r\n        @Override\r\n        public void onServiceDisconnected(ComponentName arg0) {\r\n            isStmServiceBound = false;\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n**activity_main.xml**\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:paddingBottom=\"@dimen/activity_vertical_margin\"\r\n    android:paddingLeft=\"@dimen/activity_horizontal_margin\"\r\n    android:paddingRight=\"@dimen/activity_horizontal_margin\"\r\n    android:paddingTop=\"@dimen/activity_vertical_margin\"\r\n    tools:context=\"com.mycompany.teststmsdk.MainActivity\">\r\n\r\n    <TextView\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Hello World!\"\r\n        android:id=\"@+id/textView\"/>\r\n\r\n    <EditText\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:id=\"@+id/editTextUserHandle\"\r\n        android:inputType=\"textNoSuggestions\"\r\n        android:layout_below=\"@id/textView\"\r\n        android:layout_alignParentLeft=\"true\"\r\n        android:layout_alignParentStart=\"true\"\r\n        android:layout_marginTop=\"118dp\" />\r\n\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Change Handle\"\r\n        android:id=\"@+id/button\"\r\n        android:layout_below=\"@id/editTextUserHandle\"\r\n        android:layout_alignParentLeft=\"true\"\r\n        android:layout_alignParentStart=\"true\"\r\n        android:onClick=\"setUserHandle\" />\r\n\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Delete Last Shout\"\r\n        android:id=\"@+id/deleteShoutButton\"\r\n        android:layout_toRightOf=\"@id/button\"\r\n        android:layout_marginTop=\"71dp\"\r\n        android:onClick=\"deleteShout\"\r\n        android:visibility=\"invisible\" />\r\n\r\n    <Button\r\n        android:layout_width=\"wrap_content\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"Record a Shout\"\r\n        android:id=\"@+id/startRecording\"\r\n        android:layout_alignParentLeft=\"true\"\r\n        android:layout_alignParentStart=\"true\"\r\n        android:layout_marginTop=\"71dp\"\r\n        android:onClick=\"launchRecordingOverlay\" />\r\n\r\n</RelativeLayout>\r\n```\r\n\r\nAfter the code has been modified, click **Run -> Run 'app'** to build and start the app.  You should see the initial Activity with the Start Recording button enabled.  When you press that button, it will launch the Shout to Me recording overlay as seen in the following images and immediately begin recording. Pressing the Done button on the overlay will transmit the recorded audio to the Shout to Me service for processing.\r\n\r\n![Sample app](https://s3-us-west-2.amazonaws.com/sdk-public-images/sample-app-3.png)\r\n![Shout to me overlay](https://s3-us-west-2.amazonaws.com/sdk-public-images/sample-app-4.png)\r\n\r\n## SDK Documentation\r\n\r\n### Dependencies\r\n\r\n#### Google Play Services\r\nThe Shout to Me SDK utilizes [Google Play Services Location Services](https://developers.google.com/android/reference/com/google/android/gms/location/package-summary).  If the mobile user does not have the required Google Play Services, the application may not function properly.  Google Play Services provides a convenient mechanism to prompt the user to install or upgrade their Google Play Services if applicable.\r\n\r\n```java\r\nGoogleApiAvailability googleApiAvailability = GoogleApiAvailability.getInstance();\r\nint val = googleApiAvailability.isGooglePlayServicesAvailable(this);\r\nif (val != ConnectionResult.SUCCESS) {\r\n    Dialog gpsErrorDialog = googleApiAvailability.getErrorDialog(this, val, 2);\r\n    gpsErrorDialog.show();\r\n}\r\n```\r\n\r\n#### Volley\r\nThe Shout to Me SDK utilizes Volley to optimize asynchronous communication with the API service.  For more information about volley, see the [Android Volley documentation](https://developer.android.com/training/volley/index.html).\r\n\r\n#### Amazon Web Services\r\nThe Shout to Me SDK utilizes AWS to send push notifications to mobile devices.  For more information about the Amazon Android AWS SDK, see the [Amazon mobile SDK documentation](https://aws.amazon.com/mobile/sdk/).\r\n\r\n### Permissions\r\nThe Shout to Me SDK requests the following permissions in the manifest:\r\n\r\n```xml\r\n<uses-permission android:name=\"android.permission.INTERNET\" />\r\n<uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\r\n<uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\r\n```\r\n\r\nBeginning with API level 23 (6.0), [Android requires that certain permissions be requested at run time](https://developer.android.com/training/permissions/requesting.html). The Shout to Me SDK uses two permissions that fall into this category:\r\n\r\n1. Mic/Record Audio (Required)\r\n2. Location (Optional)\r\n\r\n#### Record Audio\r\nBeing that Shout to Me is an audio-based platform, this permission is considered required.  Launching the recording overlay without the permission will result in a failure response indicating that the record audio permission is denied.  Here is an example of one way to check for this permission and requesting it if not granted:\r\n```java\r\nif (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {\r\n    // User has not granted access to record audio.  Ask the user for permission now.\r\n    ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.RECORD_AUDIO }, 0);\r\n}\r\n```\r\n\r\n#### Location\r\nUse of location functionality is optional in the Shout to Me platform.  However, if location permission is enabled, the coordinates (lat/lon) of the person shouting are included with the Shout creation request and broadcasters will be able to see the location of the user.  \r\n```java\r\nif (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED\r\n        || ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {\r\n    ActivityCompat.requestPermissions(this, new String[] { Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION }, 0);\r\n}\r\n```\r\n\r\nIf the user rejects the permission request, there is a way to explain the rationale for the request.  This is beyond the scope of this document.  More information can be found in the [Android - Request Permissions documentation](https://developer.android.com/training/permissions/requesting.html#perm-request). \r\n\r\n### StmService\r\nThe StmService class is the object developers will use to establish integration with the Shout to Me system.  It is implemented as a [bound service](http://developer.android.com/guide/components/bound-services.html) in Android to provide developers with a convenient, native way to integrate with. Here is an example of one way to check for this permission and requesting it if not granted:\r\n\r\n```java\r\n/**\r\n * StmService\r\n * Main class to access Shout to Me SDK functionality\r\n * Requires a client access token\r\n */\r\npublic class StmService extends Service\r\n```\r\n\r\nSample binding with StmService through the Android ServiceConnection class\r\n\r\n```java\r\nprivate ServiceConnection stmServiceConnection = new ServiceConnection() {\r\n\r\n    @Override\r\n    public void onServiceConnected(ComponentName className,\r\n                                   IBinder service) {\r\n        // We've bound to StmService, cast the IBinder and get StmService instance\r\n        Log.d(TAG, \"in onServiceConnected\");\r\n        StmService.StmBinder binder = (StmService.StmBinder) service;\r\n        stmService = binder.getService();\r\n        isStmServiceBound = true;\r\n    }\r\n\r\n    @Override\r\n    public void onServiceDisconnected(ComponentName arg0) {\r\n        isStmServiceBound = false;\r\n    }\r\n};\r\n    \r\n// Bind to StmService\r\nIntent intent = new Intent(this, StmService.class);\r\nbindService(intent, stmServiceConnection, Context.BIND_AUTO_CREATE);\r\n```\r\n\r\nUnbinding\r\n\r\n```java    \r\nunbindService(stmServiceConnection);\r\n```\r\n\r\n#### AndroidManifest.xml\r\nThe StmService gets the Shout to Me client token from metadata in the AndroidManifest.xml.  Optionally, you can wire up the channel ID if your app will only use one channel. Be sure to set your own string resources.\r\n```xml\r\n<service\r\n    android:name=\"me.shoutto.sdk.StmService\"\r\n    android:exported=\"false\">\r\n    \r\n    <meta-data\r\n        android:name=\"me.shoutto.sdk.CLIENT_TOKEN\"\r\n        android:value=\"@string/client_token\" />\r\n    \r\n    <!-- Optional -->\r\n    <meta-data\r\n        android:name=\"me.shoutto.sdk.CHANNEL_ID\"\r\n        android:value=\"@string/channel_id\" />\r\n</service>\r\n```\r\n\r\n#### Getting the user's authentication token\r\nWhile the SDK is meant to provide easy access to the Shout to Me API service, if you wish to send direct \r\nrequests to the Shout to Me REST API, you will need the user's authentication token.\r\nTo get the auth token, call the following method on StmService.  The first time this method is called,\r\nit blocks until the auth token is retrieved.  Therefore, either call this method on a background thread,\r\nor be prepared to handle an error in the event that the auth token has not yet been retrieved.\r\n\r\nOnce retrieved from the server, the auth token is stored in the device shared preferences to save time on\r\nfuture retrievals and across app sessions.\r\n\r\n```java\r\nstmService.getUserAuthToken();\r\n```\r\n\r\n#### Refreshing the user's authentication token\r\nThe SDK will abstract out much of the authentication tasks for you.  In the rare instance that requests are\r\nreturned as unauthorized or when switching between test and production URLs, you can call the following method \r\nto refresh the user's authentication token.  This is a synchronous method and should be done on a background thread.\r\n\r\n```java\r\nstmService.refreshUserAuthToken();\r\n```\r\n\r\n#### Hand wave gesture initiated Shout recording\r\nThe Shout to Me SDK includes a usability feature design to help make the app safe for driving.  When\r\nenabled, a driver need only wave their hand in front of the phone to launch the\r\n[StmRecorderActivity](#stm-recorder-activity).\r\n\r\nThe hand wave gesture functionality utilizes the phone's proximity sensor.  Therefore, if a phone\r\ndoes not have a proximity sensor, or the user has revoked proximity sensor permission, the\r\nfunctionality will not work.\r\n\r\nTo enable the hand wave gesture functionality, simply register a listener to the following StmService method:\r\n\r\n```java\r\npublic class MainActivity extends Activity implements HandWaveGestureListener {\r\n\r\n    private ServiceConnection stmServiceConnection = new ServiceConnection() {\r\n\r\n        @Override\r\n        public void onServiceConnected(ComponentName className,\r\n                                       IBinder service) {\r\n            StmService.StmBinder binder = (StmService.StmBinder) service;\r\n            stmService = binder.getService();\r\n            isStmServiceBound = true;\r\n\r\n            regsiterHandWaveGestureListener();\r\n        }\r\n\r\n        @Override\r\n        public void onServiceDisconnected(ComponentName arg0) {\r\n            isStmServiceBound = false;\r\n        }\r\n    };\r\n\r\n    @Override\r\n    public void onHandWaveGesture() {\r\n        launchRecordingOverlay(null);\r\n    }\r\n\r\n    private void regsiterHandWaveGestureListener() {\r\n        stmService.registerHandGestureListener(this);\r\n    }\r\n}\r\n```\r\n\r\nOnce enabled, the Shout to Me SDK continues to listen for events from the proximity sensor.\r\nUn-registering the listener will turn off the proximity event listening, thereby conserving device\r\nresources.\r\n\r\n```java\r\nstmService.unregisterHandGestureListener(this);\r\n```\r\n\r\nNote that you can specify more than one hand wave gesture listener if you want to take advantage\r\nof the functionality, however, be sure to un-register them all to effectively turn off the\r\nproximity sensor event listening.\r\n\r\n### <a name=\"callback\"></a>Callback\r\nThe Android system [does not allow asynchronous calls to be made on the main (UI) thread](http://developer.android.com/guide/components/processes-and-threads.html). The Callback class is used to provide methods you would like to have executed following the asynchronous calls to the Shout to Me service.  Callback is an abstract class with two methods that can be overridden.  \r\n\r\n```java\r\npublic abstract class Callback<T> implements StmCallback<T> {\r\n\r\n    public abstract void onSuccess(StmResponse<T> stmResponse);\r\n    public abstract void onFailure(StmError stmError);\r\n}\r\n```\r\n\r\n### StmError\r\nThe StmError class encapsulates information in the event of an error during asynchronous processing.  It is provided to the Callback `onFailure` method.  A \"blocking error\" occurs when the system determines that the client application cannot continue using Shout to Me functionality, such as if the Shout to Me service is unreachable.\r\n\r\n```java\r\npublic class StmError {\r\n\r\n    public static final String SEVERITY_MAJOR = \"major\";\r\n    public static final String SEVERITY_MINOR = \"minor\";\r\n\r\n    public String getMessage() {\r\n        return message;\r\n    }\r\n\r\n    public String getSeverity() {\r\n        return severity;\r\n    }\r\n\r\n    public boolean isBlockingError() {\r\n        return blockingError;\r\n    }\r\n}\r\n```\r\n\r\n### User\r\nThe User object represents the Shout to Me user entity that is bound to your application.  Although you may have your own user domain objects, Shout to Me still needs a context in which to create shouts, accumulate statistics, etc.  A Shout to Me user created by your mobile app will be unique to your system.  For example, if a mobile user has installed two apps that utilize the Shout to Me SDK on the same phone, there will be two distinct Shout to Me users, one for each app.  Much of the generic code around creating and authenticating the user is hidden from you by the SDK to make your life easier.  However, there are a few items that do need to be exposed, such as setting a user handle to match the handle in your system.\r\n\r\nRetrieving the user object from StmService can be done with or without a [Callback](#callback). Retrieving the user object without a [Callback](#callback) does not guarantee that the user object will have been initialized by the service, however, it is convenient for certain scenarios such as wanting to change the user's handle.\r\n\r\n```java\r\n// Without a callback\r\nUser user = stmService.getUser()\r\n\r\n// With a callback\r\nstmService.getUser(new Callback<User>() {\r\n    @Override\r\n    public void onSuccess(final StmResponse<User> stmResponse) {\r\n        Log.d(TAG, \"Shout to Me user has been loaded\");\r\n\t\t\r\n\tUser user = stmResponse.get();\r\n\tLog.d(TAG, \"User's handle is: \" + user.getHandle());\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(final StmError stmError) {\r\n        Log.w(TAG, \"Could not retrieve Shout to Me user.\");\r\n    }\r\n});\r\n```\r\n\r\nRetrieving and updating the user’s handle.  Calling `save(Callback<User>)` is required to persist the new handle to the Shout to Me service.\r\n\r\n```java\r\nString handle = user.getHandle();\r\n\r\nUser user = stmService.getUser();\r\nuser.setHandle(\"BobSmith\");\r\nuser.save(new Callback<User>() {\r\n    @Override\r\n    public void onSuccess(final StmResponse<User> stmResponse) {\r\n        Log.d(TAG, \"User handle update was successful. Handle is \" + stmResponse.get().getHandle());\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(final StmError stmError) {\r\n        Log.w(TAG, \"Could not save changes to user. Message is: \" + stmError.getMessage());\r\n    }\r\n});\r\n```\r\n\r\n### Shout\r\nThe Shout object represents the recording a user created and its metadata in the Shout to Me system.  Although generally a read-only object to the mobile user, an administrative user can make updates to it, such as making it public or private, and queuing it to be played on-air.\r\n\r\nCurrently the only time a client app will interact with a Shout is in the [StmRecorderActivity](#stm-recorder-activity) callback.  \r\n\r\nDeleting a shout\r\n\r\n```java\r\nshout.delete(new Callback<String>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<String> stmResponse) {\r\n        if (stmResponse.get().equals(\"success\")) {\r\n            Log.d(TAG, \"Deletion of shout succeeded.\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.e(TAG, \"Error occurred deleting shout. Error message: \" + stmError.getMessage());\r\n    }\r\n});\r\n```\r\n\r\n### <a name=\"channel\"></a>Channel\r\nThe Channel object represents one or more channels that you may have configured in your Shout to Me account.  The Channel object contains metadata and default configuration values that can be used to display information to your users.\r\n\r\n```java\r\npublic class Channel {\r\n\r\n    public String getId()\r\n\r\n    public String getName()\r\n\r\n    public String getDescription()\r\n\r\n    // The URL of an image that can be used to show the user what channel they are on\r\n    public String getImageUrl()\r\n\r\n    // A smaller version of the channel image to display in lists\r\n    public String getListImageUrl()\r\n\r\n    // The maximum recording length in seconds allowed for the channel\r\n    public int getDefaultMaxRecordingLengthSeconds()\r\n}\r\n```\r\n\r\nRetrieving channels\r\n\r\n```java\r\nstmService.getChannels(new Callback<List<Channel>>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<List<Channel>> stmResponse) {\r\n        List<Channel> channels = stmResponse.get();\r\n        for (Channel channel : channels) {\r\n            Log.d(TAG, \"Image URL for \" + channel.getName() + \" is \" + channel.getImageUrl());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.w(TAG, \"Could not retrieve channel list\");\r\n    }\r\n});\r\n```\r\n\r\n#### Channel Subscriptions\r\nA subscription to a channel indicates that push notifications will be sent to the app when a broadcaster\r\npublishes a channel-wide message.  The SDK provides a way for the client app to subscribe, unsubscribe and\r\ntell if the user is currently subscribed or not.  This can be used in an app setting to allow the user\r\ncontrol over their subscription status.\r\n\r\nDetermining subscription status\r\n\r\n```java\r\nchannel.isSubscribed(new Callback<Boolean>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<Boolean> isSubscribedResponse) {\r\n        if (isSubscribedResponse.get()) {\r\n            Log.d(TAG, \"User is subscribed to channel\");\r\n        } else {\r\n            Log.d(TAG, \"User is not subscribed to channel\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.w(TAG, \"An error occurred checking user's subscribed status. \" + stmError.getMessage());\r\n    }\r\n});\r\n```\r\n\r\nSubscribing to a channel\r\n\r\n```java\r\nchannel.subscribe(new Callback<Void>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<Void> subscribeResponse) {\r\n        Log.d(TAG, \"User is now subscribed\");\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.w(TAG, \"An error occurred subscribing to channel. \" + stmError.getMessage());\r\n    }\r\n});\r\n```\r\n\r\nUnsubscribing to a channel\r\n\r\n```java\r\nchannel.unsubscribe(new Callback<Void>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<Void> unsubscribeResponse) {\r\n        Log.d(TAG, \"User is now unsubscribed.\");\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.w(TAG, \"An error occurred unsubscribing to channel. \" + stmError.getMessage());\r\n    }\r\n});\r\n```\r\n\r\n### Message\r\nThe Message object represents text or audio messages that can be sent from broadcasters to users.  A\r\nuser may receive messages from more than one channel if the client app supports multiple channels.\r\n\r\n```java\r\npublic class Message {\r\n\r\n    public String getId()\r\n\r\n    public Channel getChannel()\r\n\r\n    // The actual message text\r\n    public String getMessage()\r\n\r\n    // The name of the sender.  May be null if was sent via a channel-wide notification\r\n    public String getSenderName()\r\n\r\n    public Date getSentDate()\r\n\r\n    // A reference to a Shout to Me conversation.  May be null\r\n    public String getConversationId()\r\n}\r\n```\r\n\r\nRetrieving messages\r\n\r\nA maximum of 1000 messages will be returned.\r\n\r\n```java\r\nstmService.getMessages(new Callback<List<Message>>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<List<Message>> messagesResponse) {\r\n        List<Message> messageList = messagesResponse.get();\r\n        Log.d(TAG, \"Number of messages = \" + String.valueOf(messageList.size()));\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.w(TAG, \"Could not retrieve message list\");\r\n    }\r\n});\r\n```\r\n\r\nCreating a message\r\n\r\nAt certain times a client app may need to create a message for persistence in the user's message records.\r\nA Builder class is provided to help with this.\r\n\r\n```java\r\nstmService.getMessageBuilder()\r\n    .channelId(channelId)\r\n    .conversationId(conversationId)\r\n    .message(messageBody)\r\n    .recipientId(stmService.getUser().getId())\r\n    .create(new Callback<Message>() {\r\n        @Override\r\n        public void onSuccess(StmResponse<Message> response) {\r\n            Message message = response.get();\r\n            Log.d(TAG, \"Message created successfully \" + message.getId());\r\n        }\r\n\r\n        @Override\r\n        public void onFailure(StmError stmError) {\r\n            Log.w(TAG, \"Error creating message \" + stmError.getMessage());\r\n        }\r\n    });\r\n```\r\n\r\n### <a name=\"stm-recorder-activity\"></a>StmRecorderActivity\r\nThe StmRecorderActivity is a native Android [Activity](http://developer.android.com/reference/android/app/Activity.html) used to quickly and easily enable recording in a client app.  When the StmRecorderActivity is launched, the following will occur:\r\n\r\n1. The StmRecorderActivity is displayed to the user\r\n2. Audio recording immediately begins\r\n3. The user is presented with two options\r\n    * A “Done” button; when pressed, this will stop the recording and send the recorded audio to the server.  The StmRecorderActivity will then be closed.\r\n    * A “Cancel” icon; when pressed, the recording will be stopped and the StmRecorderActivity will be closed.\r\n\r\nThere is also the ability to provide an optional callback if you would like to receive an Shout object following the creation of the shout.\r\n\r\n```java\r\nstmService.setShoutCreationCallback(new Callback<Shout>() {\r\n    @Override\r\n    public void onSuccess(StmResponse<Shout> stmResponse) {\r\n        Log.d(TAG, \"Shout created successfully. ID = \" + stmResponse.get().getId());\r\n        shout = stmResponse.get();\r\n    }\r\n\r\n    @Override\r\n    public void onFailure(StmError stmError) {\r\n        Log.e(TAG, \"An error occurred during shout creation. Message is \" + stmError.getMessage());\r\n    }\r\n});\r\n```\r\n\r\n#### Launching the StmRecorderActivity\r\nLaunching the StmRecorderActivity is done using standard Android Activity functionality.  You can pass in certain extras to provide additional data.\r\n\r\n1. StmRecorderActivity.MAX_RECORDING_TIME_IN_SECONDS - This extra is required. Maximum recording times can be found in [Channel](#channel) data.  Please note that the Shout to Me system currently does not support recording times over 1 minute.\r\n2. StmRecorderActivity.TAGS - A comma separated list of tags that will flow through to the Broadcaster Application.\r\n2. StmRecorderActivity.TOPIC - A topic that will flow through to the Broadcaster Application.\r\n\r\n```java\r\nIntent intent = new Intent(this, StmRecorderActivity.class);\r\nintent.putExtra(StmRecorderActivity.MAX_RECORDING_TIME_IN_SECONDS, maxRecordingLengthSeconds);  // Required\r\nintent.putExtra(StmRecorderActivity.TAGS, tags);                                                // Optional\r\nintent.putExtra(StmRecorderActivity.TOPIC, topic);                                              // Optional\r\nstartActivityForResult(intent, 1); \r\n```\r\n\r\n#### Handling the Activity result of StmRecorderActivity\r\nThe StmRecorderActivity uses the standard Android callback to indicate whether the Activity was closed OK, or whether the action was cancelled.  In addition, the StmRecorderActivity will provide data to confirm whether or not the recording process completed successfully or not.  The example below shows how to detect the StmRecorderActivity.RECORD_AUDIO_PERMISSION_DENIED failure.\r\n\r\n```java\r\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\r\n\r\n    if (requestCode == MY_REQUEST_CODE) {\r\n        if (resultCode == RESULT_OK){\r\n            String recordingResult = data.getStringExtra(StmRecorderActivity.ACTIVITY_RESULT);\r\n            Log.d(TAG, \"The recording overlay has closed successfully. Result is: \" + recordingResult);\r\n            \r\n            if (recordingResult.equals(StmService.FAILURE)) {\r\n                String failureReasonCode = data.getStringExtra(StmRecorderActivity.ACTIVITY_REASON);\r\n                Log.d(TAG, \"Failure code: \" + failureReasonCode);\r\n                    if (failureReasonCode.equals(StmRecorderActivity.RECORD_AUDIO_PERMISSION_DENIED)) {\r\n\r\n                        Log.w(TAG, \"User has not granted the RECORD_AUDIO permission\");\r\n                    }\r\n                } \r\n       }\r\n       if (resultCode == RESULT_CANCELED) {\r\n           // Write your code if there's no result\r\n           Log.d(TAG, \"recording cancelled\");\r\n       }\r\n    }\r\n}\r\n```\r\n\r\n### Notifications\r\nThe Shout to Me SDK supports receiving push notifications from the Shout to Me platform.  There are a number of technologies used in receiving notifications, and consequently, there are a number of items that need to be wired up. The following high level steps occur in the notifications system:\r\n\r\n1. A notification is received from GCM\r\n2. The SDK processes the notification and may do one of two things:\r\n    a. Immediately broadcast a message to the client app\r\n    b. Create a geofence which may be triggered later if and when a user enters the geofence area\r\n3. A listener in the client app receives a broadcast and displays data to the mobile user\r\n\r\n#### GCM\r\nThe Shout to Me system uses (GCM)[https://developers.google.com/cloud-messaging/] to send and receive messages. Add the following to your AndroidManifest.xml if you wish to receive notifications.  Be sure to set your own values for the string resource references.  Check with Shout to Me support for specific values to use.\r\n\r\n```xml\r\n<service\r\n    android:name=\"me.shoutto.sdk.GcmNotificationRegistrationIntentService\"\r\n    android:exported=\"false\">\r\n    <meta-data android:name=\"me.shoutto.sdk.GcmDefaultSenderId\" android:value=\"@string/gcm_default_sender_id\" />\r\n    <meta-data android:name=\"me.shoutto.sdk.PlatformApplicationArn\" android:value=\"@string/platform_application_arn\" />\r\n    <meta-data android:name=\"me.shoutto.sdk.IdentityPoolId\" android:value=\"@string/identity_pool_id\" />\r\n</service>\r\n\r\n<!-- [START gcm_receiver] -->\r\n<receiver\r\n    android:name=\"com.google.android.gms.gcm.GcmReceiver\"\r\n    android:exported=\"true\"\r\n    android:permission=\"com.google.android.c2dm.permission.SEND\">\r\n    <intent-filter>\r\n        <action android:name=\"com.google.android.c2dm.intent.RECEIVE\" />\r\n        <category android:name=\"me.shoutto.sdk\" />\r\n    </intent-filter>\r\n</receiver>\r\n<!-- [END gcm_receiver] -->\r\n\r\n\r\n<!-- [START gcm_listener] -->\r\n<service\r\n    android:name=\"me.shoutto.sdk.StmGcmListenerService\"\r\n    android:exported=\"false\">\r\n    <intent-filter>\r\n        <action android:name=\"com.google.android.c2dm.intent.RECEIVE\" />\r\n    </intent-filter>\r\n</service>\r\n<!-- [END gcm_listener] -->\r\n\r\n\r\n<!-- [START instanceId_listener] -->\r\n<service\r\n    android:name=\"me.shoutto.sdk.GcmInstanceIDListenerService\"\r\n    android:exported=\"false\">\r\n    <intent-filter>\r\n        <action android:name=\"com.google.android.gms.iid.InstanceID\" />\r\n    </intent-filter>\r\n</service>\r\n<!-- [END instanceId_listener] -->\r\n```\r\n\r\n#### Geofencing\r\nLocation based notifications will be created as (geofences)[https://developers.google.com/android/reference/com/google/android/gms/location/Geofence] in the Shout to Me SDK.  Add this to your AndroidManifest.xml to allow the SDK to listen for geofence events:\r\n\r\n```xml\r\n<service android:name=\"me.shoutto.sdk.GeofenceTransitionsIntentService\" />\r\n```\r\n\r\n#### Shout to Me Broadcasts\r\nThe Shout to Me SDK uses a standard Android broadcast to send the processed message data to client apps.  Add the following to your AndroidManifest.xml to listen for these broadcasts.  Of course, you will need to supply your own listener class. In this example, it is called StmNotificationReceiver.\r\n\r\n```xml\r\n<receiver\r\n    android:name=\".StmNotificationReceiver\"\r\n    android:exported=\"false\">\r\n    <intent-filter>\r\n        <action android:name=\"me.shoutto.sdk.EVENT_MESSAGE_NOTIFICATION_RECEIVED\" />\r\n    </intent-filter>\r\n</receiver>\r\n```\r\n\r\nThe broadcast receiver class should include something similar to the following to retrieve the broadcast data:\r\n\r\n```java\r\n@Override\r\npublic void onReceive(Context context, Intent intent) {\r\n    Bundle data = intent.getExtras();\r\n    body = data.getString(MessageNotificationIntentWrapper.EXTRA_NOTIFICATION_BODY);\r\n    channelId = data.getString(MessageNotificationIntentWrapper.EXTRA_CHANNEL_ID);\r\n    channelImageUrl = data.getString(MessageNotificationIntentWrapper.EXTRA_CHANNEL_IMAGE_URL);\r\n    title = data.getString(MessageNotificationIntentWrapper.EXTRA_NOTIFICATION_TITLE);\r\n    type = data.getString(MessageNotificationIntentWrapper.EXTRA_NOTIFICATION_TYPE);\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}